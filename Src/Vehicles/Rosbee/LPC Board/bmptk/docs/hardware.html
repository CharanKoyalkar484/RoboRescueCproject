<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Bare Metal Programming Tool Kit: Pins and ports</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bmptk-blue.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bare Metal Programming Tool Kit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Pins and ports </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Bmptk abstracts pins, ports and most chips as static classes. There are no objects of these classes, instead the name of the class representing the abstraction is passed as a template parameter to other abstractions.</p>
<p>For example, to interface to a PCF8574A I2C I/O extender, the pins that are used as I2C clock and I2C data (which are themselves static classes in the bmptk::target class) are used to instatiate an I2C bus class. This I2C bus class is in turn uses to instantiate a PCF8574A class. Finally, to blink a single LED connected to an output pin of the PCF8574A, a blink function is instantiated and called. (examples/db103/pcf8574a-blink/main.cpp): </p>
<div class="fragment"></div><!-- fragment --><p>The main reason to use static classes is that the compiler can generate compact and fast code. A consequence is that the abstractions are not objects, hence they can not be passed around as parameters. Hence the 'structure' describing the hardware is static: it can not be changed at run time. This means that there can be no problems like dangling references or stale pointers.</p>
<p>No objects of the static classes are ever made, hence the initialization can not be done in the constructor. Instead each static class has an init() method, that must be called before any other method of the class is used. Calling the init() method is the responsibility of the code that acually uses the pin (not of the main).</p>
<p>This page describes the elements of the bmptk hardware abstraction:</p>
<ul>
<li><a class="el" href="hardware.html#hardware-pins">Pins</a></li>
<li><a class="el" href="hardware.html#hardware-ports">Ports</a></li>
<li><a class="el" href="hardware.html#hardware-conversions">Conversions</a></li>
<li><a class="el" href="hardware.html#hardware-decorators">Decorators</a></li>
</ul>
<hr/>
<p><a class="anchor" id="hardware-pins"></a></p>
<h2>Pins</h2>
<p>A microcontroller interfaces with external electronics via its I/O pins. These pins come in different flavours: input-only, output-only, input-output and open-collector. Each flavour is characterised by an (interface-) class that defines the methods it supports.</p>
<p>An input-only pin class has a get() method that returns the current state of the pin, as determined by the external hardware.</p>
<p>And output-only pin class has a set() method that sets the external level of the pin according to the argument value.</p>
<p>And input-output pin has the get() and set() methods, and in addiion it has the direction_set_input(), direction_set_output(), direction-set() methods. The direction must be set to output before set() can be used, and must be set to input before get() can be used.</p>
<p>An open-collector (or more accurate: open-drain) pin can only sink current (short the pin to ground), not source. \ An open-collector pin is generally connected to open-collector pins of other chips, with a single pull-up resistor. This arrangement is called a wired-AND: any of the pins can pull the line low, only when all pins don't will it be pulled high by the resistor.</p>
<p>An open-collector pin has the get() and set() methods. It does not need the direction_set methods, because setting the pin high effectively makes the pin an input. </p>
<hr/>
<p><a class="anchor" id="hardware-ports"></a></p>
<h2>Ports</h2>
<p>A port is a collection of (up to 32) pins. Ports exist in the same flavous as pins: input-only, output-only, input/output, and open-collector. A port is used when it is more convenient to read (get() method) or write (set() method) an N-bit value than to read or write the individual pins. For an input/output the direction can be set, exactly as for a pin_in_out, but only for all pins of tbe port at once. A port has an n_pins() method that returns the number of pins in the port.</p>
<p>A port can be constructed from a set of pins. The pins must be 'convertible' (see Conversions) to the flavour required by the port. Up to 32 pins can be combined in this way.</p>
<p>The following class macros are available to create a port from a list of pins:</p>
<ul>
<li>bmptk::hardware::port_in_from&lt; pin, ... &gt;</li>
<li>bmptk::hardware::port_out_from&lt; pin, ... &gt;</li>
<li>bmptk::hardware::port_in_out_from&lt; pin, ... &gt;</li>
<li>bmptk::hardware::port_oc_from&lt; pin, ... &gt;</li>
</ul>
<p>A simple piece of code that uses a port is the kitt template: </p>
<div class="fragment"></div><!-- fragment --><p>The function takes a port as template argument, and optionally a time as function argument (a time value cannot be a template argument because it is neither a type nor a value of an built-in type).</p>
<p>This function template is used in the kitt demo (examples/db103/kitt/main.cpp): </p>
<div class="fragment"></div><!-- fragment --><p> This demo creates a kitt-style display on the 12 pins of a DB103 board. </p>
<hr/>
<p><a class="anchor" id="hardware-conversions"></a></p>
<h2>Conversions</h2>
<p>When this makes sense, one flavour of pin or port can be converted to another. These conversions are used, for instance by function templates, to convert an argument pin to the pin flavour that they can use.</p>
<p>The class templates that create a pin from another pin are:</p>
<ul>
<li>bmptk::hardware::pin_in_from&lt; pin &gt;</li>
<li>bmptk::hardware::pin_out_from&lt; pin &gt;</li>
<li>bmptk::hardware::pin_in_out_from&lt; pin &gt;</li>
<li>bmptk::hardware::pin_oc_from&lt; pin &gt;</li>
</ul>
<p>The template bmptk::hardware::pin_in_from&lt; pin &gt; creates an input pin from</p>
<ul>
<li>an input pin,</li>
<li>an open-collector pin, or</li>
<li>an input/output pin.</li>
</ul>
<p>It can't create an input pin from an output-only pin, of course, because an output-only pin offers no way to impement the get() method.</p>
<p>Likewise, bmptk::hardware::pin_out_from&lt; pin &gt; creates an output pin from</p>
<ul>
<li>an output pin,</li>
<li>an open-collector pin, or</li>
<li>an input/output pin.</li>
</ul>
<p>It can't create an output pin from an input pin, because an input-only pin offers no way to implement the set() method.</p>
<p>bmptk::hardware::pin_in_out_from&lt; pin &gt; creates an input/output pin from</p>
<ul>
<li>an open-collector pin, or</li>
<li>an input/output pin.</li>
</ul>
<p>It can't create an input/output pin from an input-only pin (no way to implement set()) or an output-only pin (no way to implement get(). pin.</p>
<p>bmptk::hardware::pin_oc_from&lt; pin &gt; creates an open-collector pin from</p>
<ul>
<li>an open-collector pin, or</li>
<li>an input/output pin.</li>
</ul>
<p>It can't create an open-collector pin from an input-only pin (no way to implement set()) or an output-only pin (no way to implement get()).</p>
<p>Likewise, the following class templates create a port from another port:</p>
<ul>
<li>bmptk::hardware::port_in_from&lt; port &gt;</li>
<li>bmptk::hardware::port_out_from&lt; port &gt;</li>
<li>bmptk::hardware::port_in_out_from&lt; port &gt;</li>
<li>bmptk::hardware::port_oc_from&lt; port &gt;</li>
</ul>
<hr/>
<p><a class="anchor" id="hardware-decorators"></a></p>
<h2>Decorators</h2>
<p>A decorator creates somthing with the same syntactic interface as the original, but with a twist.</p>
<p>The bmptk::hardware::invert static class macro creates a class of the same flavour from a pin or port, but with all the bits inverted. This inversion happens both on reading (get) and on writing (set).</p>
<p>The bmptk::hardware:tee static class macro combines a list of pins into a single pin_out. Writing to that single pin causes writes to all the underlying pins. Those pins must be 'convertible' to a pin_out. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
